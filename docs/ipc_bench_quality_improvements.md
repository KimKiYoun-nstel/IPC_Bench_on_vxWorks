# IPC 벤치 품질 개선안 (VxWorks 23.03 / DKM↔RTP)

목적: 현재 벤치 결과(min/p50/p90/p99/max)가 **의미 있게 비교**되고, 특히 `max` 같은 희귀 스파이크를 **설명 가능한 데이터**로 바꾸기 위한 개선점 정리.  
전제: UDP는 타겟 내부에서 `127.0.0.1` 고정(= lo0), SHM/MSGQ/SHM+SEM 등과 비교.

---

## 0) 왜 개선이 필요한가 (핵심)
- `max`는 **단 1회** 스파이크에도 크게 흔들림 → 6000 샘플(200Hz×30s)에서는 특히 불안정.
- p50/p99만으로도 충분히 결론을 낼 수 있지만, 리뷰에서 “최악값(max) 튐”이 논쟁 포인트가 되는 경우가 많음.
- 따라서 “tail(꼬리)”을 **좀 더 안정적으로** 보여주는 지표와, 스파이크가 발생한 순간을 **추적 가능하게** 만드는 장치가 필요.

---

## 1) 통계/출력 개선 (가장 ROI 큼)

### 1.1 p99.9 / p99.99 추가
- p99는 샘플의 1% (200Hz×30s면 60개)라서 비교적 안정.
- 스파이크 성향을 더 보고 싶다면 **p99.9(0.1%)**, **p99.99(0.01%)**를 추가.
- 구현: 정렬된 배열에서 인덱스만 추가 산출.

추천 출력:
- `p99_9=...ns p99_99=...ns`

### 1.2 “임계값 초과 카운트” 추가
`max` 대신 아래처럼 카운트를 같이 출력하면 설득력이 올라감:
- `over_50us`, `over_100us`, `over_1ms` 같은 버킷 카운트
- 예: `over_1ms=3/6000` 처럼 **빈도 기반** 설명 가능

### 1.3 Top-K worst RTT 목록(예: top10) 출력
- `max`가 “딱 1번” 튄 건지 “10번” 튄 건지 판단 불가 → top10 출력하면 바로 드러남.
- 구현: 정렬 후 끝에서 10개 출력.

추천 출력:
- `top10=[...ns,...ns,...]` (또는 줄바꿈)

### 1.4 요약 CSV에 “설정 메타데이터” 고정 기록
결과 비교 시 아래가 빠지면 논쟁이 생김:
- `clock_source` (DKM: sysTimestampLock, RTP: clock_gettime 등)
- `pacing_mode` (taskDelay vs hybrid)
- `rtp_prio`, `dkm_prio`, `cpu_affinity` (사용 시)
- `build_id` (git hash나 빌드 날짜)
- `vip_profile`/`image_name` (부팅 이미지 식별)

---

## 2) “스파이크 원인”을 추적 가능하게 만드는 개선

### 2.1 샘플에 “시각/시퀀스” 연동(옵션)
스파이크가 발생한 샘플 번호(`seq`)를 알고 있어도, 시스템 이벤트와 매칭이 어려움.
- 옵션으로 `seq` 또는 `t_send_ns_low32` 같은 값을 같이 저장하면
  나중에 WindView/System Viewer 로그와 대조가 쉬움.

권장: 기본 OFF, 디버그 모드에서 ON.

### 2.2 스파이크 발생 시 “즉시 로그 1줄” (rate 제한)
예: RTT가 `>1ms`면 그 순간에만 1줄 출력:
- `SPIKE seq=... rtt=...ns`
- 콘솔 출력 자체가 지터를 유발할 수 있으니, 반드시 **rate-limit**(예: 초당 1회) 적용.

### 2.3 서버(RTP) 처리 시간(옵션)도 같이 측정
RR RTT는 “왕복”이라 서버가 얼마나 빨리 응답했는지 분해가 어려움.
옵션:
- 서버가 `recv_ts`/`send_ts`를 찍고,
- 응답 payload에 `server_proc_ns = send_ts - recv_ts`를 실어 보냄
- 클라가 RTT와 함께 `server_proc_ns`를 기록하면,
  “스파이크가 서버 쪽 처리인지/전송 대기인지”를 분해 가능.

> 클라/서버가 같은 clock base를 쓰지 않아도(절대 시간 다름) 서버 내부 구간은 자체로 의미 있음.

---

## 3) pacing(송신 주기) 품질 개선

### 3.1 taskDelay 기반 pacing의 한계 명시
- 200Hz에서는 taskDelay 기반도 대체로 충분.
- 1000Hz 이상에서는 tick/스케줄링 영향으로 “samples 자체가 목표보다 줄어듦” 같은 현상이 생길 수 있음.

권장:
- `pacing=hybrid` 옵션 제공:
  - 큰 간격은 `taskDelay()`로 맞추고
  - 마지막 수십~수백 us는 `busy-wait`로 정밀 맞춤
- 단점: CPU를 더 씀 → CPU-time(THREAD_CPUTIME) 같이 기록하면 설득력↑

### 3.2 실제 송신 주기 오차 측정(옵션)
RR RTT만 보면 “rate를 제대로 맞췄는지”가 간접적으로만 보임.
옵션:
- `send_interval_ns` 통계를 별도로 수집(p50/p99/max)
- `missed_deadline` 카운트(목표 간격보다 늦은 횟수)

---

## 4) 측정 오버헤드/왜곡 줄이기

### 4.1 콘솔 출력 최소화
- 테스트 중 주기적으로 찍는 로그(초당 1회)도 tail에 영향 줄 수 있음.
- `verbose`/`quiet` 모드로 분리:
  - 기본: 시작/종료 요약만 출력
  - 디버그: 중간 진행상황 출력

### 4.2 동적할당(alloc) 제거 유지
- per-packet malloc/free가 있으면 tail이 무너짐.
- 벤치 하네스는 모든 경로에서:
  - TX/RX 버퍼 `reserve` 또는 고정 버퍼 재사용
  - 통계 샘플 배열도 사전 할당

### 4.3 CPU 캐시/코어 영향(옵션)
가능하면 아래를 선택 옵션으로:
- client/server를 서로 다른 코어에 고정(가능한 경우)
- 우선순위(prio) 고정
- 동일 조건 반복(3회 이상) 후 중간값 채택

---

## 5) 통계 계산 방식(퍼센타일) 명확화/문서화

### 5.1 방식 명시
- “정렬 후 nearest-rank(반올림 인덱스)”인지
- “floor((n-1)*p)”인지
- 보간(interpolation)인지

비교/보고서에서 통계 정의가 다르면 불필요한 논쟁이 생김.
→ 문서/로그에 `quantile=nearest_rank_round` 같은 식으로 남기기.

### 5.2 min/max는 참고 지표로 격하
- 보고서 결론은 p50/p99/p99.9 중심으로
- max는 “관측된 최악 1회”로 취급(빈도와 함께 제시)

---

## 6) 추천 “최소 변경” 체크리스트 (바로 적용용)

### 필수(강력 추천)
- [ ] p99.9 / p99.99 추가
- [ ] over_100us / over_1ms 카운트 추가
- [ ] top10 worst 출력 추가
- [ ] 로그에 clock_source / pacing_mode / prio 메타데이터 추가

### 선택(스파이크 추적용)
- [ ] RTT>1ms 시 rate-limited spike 로그
- [ ] 서버 proc time(payload에 포함) 측정 옵션

### 고주기(>=1kHz)용
- [ ] hybrid pacing 옵션
- [ ] send interval error 통계

---

## 7) 결과 해석 가이드(보고서 템플릿 문장)

- Typical(전형) 성능: `p50`  
- Tail(지터) 성능: `p99` + `p99.9` + `over_1ms 빈도`  
- Worst-case: `max`는 “관측된 최악 1회”로만 표기하고, 반드시 `top10` 및 `over_1ms`로 보강

예시:
- “p50=XXus, p99=YYus, p99.9=ZZus, over_1ms=A/B(%)”
- “max는 1회 관측 W ms(상위 10개 중 1위)”
